{"name":"Pomona","tagline":"The goddess of fruit trees, garden, and orchards","body":"# Pōmōna. The DTO-free way to REST for lazy people!\r\n\r\nPōmōna is all about exposing your domain model as a REST API. With less pain.\r\n\r\nIt was born out of my personal experience with being bored from manually implementing\r\na whole new layer of DTO (Data Transfer Object) and mapping, with the feeling that I\r\nwas repeating myself over and over.\r\n\r\nSo the goal is that Pōmōna will offer a way to do this mapping and (de)serialization\r\nby convention, and remove the need for DTO's all together. This shall be achieved by:\r\n\r\n* Supporting custom conventions, with a good set of default ways to do things.\r\n* Expose an API to override these conventions for special cases. (TODO)\r\n  Yeah sure it should be Fluent, for the cool kids! ;)\r\n* Making it possible to generate an easy-to-use .NET client dll on-the-fly.\r\n* Make it possible to specify what references to expand and not.\r\n\r\nAdditionally I also want it to be able to:\r\n\r\n* Semi-automatic management of REST API versioning by inspection of changes in JSON schema. (TODO)\r\n\r\nOh, by the way, for all nitpickers out there. I use the REST definition freely. I believe\r\nit will be possible to expose a somewhat RESTful API through Pōmōna someday, but oh course\r\nit all depends on the domain model mapped.\r\n\r\n## State of the project\r\n\r\nAlthough usable for simple scenarios, Pōmōna should be considered early work-in-progress stuff.\r\nIt will change. A lot. It's for the adventurous and the rebels! ;)\r\n\r\nMy personal goal is to release a version 1.0 before christmas. But no promises, yet.\r\n\r\n## On the shoulders of really cool people:\r\n\r\n* [JSON.NET](ttp://james.newtonking.com/projects/json-net.aspx) for serialization stuff. h\r\n* [Nancy](http://nancyfx.org/) for hosting the web service. \r\n  I really love Nancy! I can't overstate how good I think it is! <3 <3 <3\r\n  One day I hope Pōmōna will offer a Super-Duper-Happy path just like it.\r\n* [NUnit](http://www.nunit.org/) for testing.\r\n* [Cecil](http://www.mono-project.com/Cecil) for generation of Client dll.\r\n* [google-code-prettify](http://code.google.com/p/google-code-prettify/) for presenting JSON as HTML.\r\n\r\nA huge thank you to all the authors of these projects.\r\n\r\n## Getting started\r\n\r\nSo if you really want to check this stuff out, here's how you get started.\r\n\r\n1. Implement your own `IPomonaDataSource`\r\n2. Inherit from `TypeMappingFilterBase`, and at a minimum implement `GetSourceTypes()` and `GetIdFor()`.\r\n   They're abstract, so you can't miss them.\r\n   `GetSourceTypes()` must return the list of what Types to expose to web service.\r\n3. Inherit `PomonaModule` (which is a Nancy module), and treat this as you normally would treat a Nancy module.\r\n   Which could mean zero configuration. Just because Nancy is *that* awesome!\r\n4. Inherit PomonaConfigurationBase and fill in the abstracts.\r\n\r\nLook at the Critter example in the source code for details. If you fire up the `Pomona.Example.ServerApp.exe`, it expose the critters on port 2211.\r\nWhen ServerApp is running go here with a web browser to see what Pōmōna is all about:\r\n\r\n* `http://localhost:2211/critters`\r\n* `http://localhost:2211/critters?$expand=critter.hat`\r\n* `http://localhost:2211/Critters.Client.dll` - Generates a client library on-the-fly\r\n* `http://localhost:2211/Critters.Client.1.0.0.0.nupkg` - Generates a [NuGet Package](http://www.nuget.org/) for the client library on-the-fly\r\n* `http://localhost:2211/schemas` - Returns the JSON schema for the transformed data model\r\n* \r\nYou can also `POST` to `http://localhost:2211/critter` create a new critter entity, or `PUT` to `http//localhost:2211/critter/<id>` to update the values of a critter.\r\n\r\n## Roadmap for first release\r\n\r\nFeatures:\r\n* Add tests for serialization and deserialization on client DONE\r\n* Create IPomonaDataSource, for retrieval of data. DONE\r\n* Create PomonaSession and PōmōnaSessionFactory that will bind everything together.\r\n* Write correct metadata for generated client dll (AssemblyInfo etc..)\r\n* Implement support for value types (which is always expanded, and don't have URI). 90% DONE.\r\n* Implement simple query mechanism (Linq? relinq? something simpler?) 90% DONE.\r\n  * Syntax inspired by OData, with some differences.\r\n  * Most OData operators are supported, but functions are missing.\r\n* Create a test helper that will compare an existing JSON schema with new one,\r\n  then detect any breaking changes in API.\r\n* Implement proper PATCH functionality.\r\n* ETags and versioning\r\n\r\n## Future tasks\r\n\r\n* Implement JS client lib. Maybe two types, one based on KnockoutJs? That would be cool.\r\n* Implement html media type for friendly browseing.\r\n* Implement batch fetching on client side\r\n* Batch query support, for example by encapsulating an array of http operations in a JSON array\r\n\r\n# Brainstorm area\r\n## Implementation of automatic API compatibility checking\r\n\r\nFor this to work we need to:\r\n* Have a api schema folder specified.\r\n* Have a method writing out existing schemas with version numbering: {api-name}.{version}.json\r\n* Find a way to whitelist a breaking API change.\r\n* Implement class ApiChangeVerifier.\r\n* Encourage having an ignored test that outputs current schema.\r\n\r\n## Random ideas\r\n\r\n* Could make query mechanism pluggable, through some sort of `IHttpQueryTranslator`.\r\n  Then we could provide a simple default implementation.\r\n\r\n* An exotic side-project could be to implement an `IHttpQueryTranslator` that uses relinq\r\n  to serialize and convert LINQ expressions, which then can be executed on Nhibernate or other ORM.\r\n  This does however seem a bit dangerous with regards to security.\r\n\r\n## Automated batching of queries to decrease N+1 performance problems\r\n\r\nThe classic N+1 problem will appear when looping through a list, where we at each step\r\naccess a reference to another object, which will then be loaded. Although Pōmōna supports\r\nsending a list of expanded paths to deal with these problems, it would be sorta cool if\r\nthis could be detected runtime and fixed.\r\n\r\nThis is one way to do it (by example). We got two simple entity types:\r\n\r\nCustomer example:\r\n```json\r\n{\r\n    \"name\" : \"The first name\",\r\n    \"order\" : {\r\n        \"_ref\" : \"http://blah/order/1\"\r\n    }\r\n}\r\n```\r\n\r\nOrder example:\r\n```json\r\n{\r\n    \"_uri\" : \"http://blah/order/1\",\r\n    \"description\" : \"This is a order\",\r\n}\r\n```\r\n\r\nThis can be accomplished by keeping track of what properties have been accessed, and in what order.\r\n\r\nLets say we get a list of 30 customers by some criteria that is supposed to be presented\r\nin a table along with the order description.. And we iterate through the customers in order.\r\n\r\nTotal query count: 1\r\n\r\n`customers[0].Order.Description` is accessed first, which, as is normal, makes the first order loaded.\r\nWe take a note that Order of description has been loaded for first Customer, and double the prefetch\r\ncount for the path Customer.Order, from 1 (no prefetching) to 2.\r\n\r\nTotal query count: 2\r\n\r\n`customers[1].Order.Description` is accessed next time, which loads Order for both customer #1 and customer #2.\r\nThen prefetch count is doubled again from 2 to 4.\r\n\r\n`customers[2].Order` is already prefetched, so nothing needs to be loaded for that.\r\n\r\nTotal query count: 3\r\n\r\nThe `customers[3].Order` is accessed, which loads Order for customer #3,#4,#5,#6. The prefetch count is\r\ndoubled again.\r\n\r\nTotal query count: 4\r\n\r\nAnd so on:\r\n\r\nQuery 5: Order #7, #8, #9, #10, #11, #12, #13, #14 loaded\r\nQuery 6: Order #15, #16, #17, #18, #19, #20, #21, #22, #23, #24 loaded\r\n\r\nThis gives a total of 6 http requests instead of 26, which means instead of N+1 we have Log2(N)+1 operations.\r\n","google":"UA-7336224-10","note":"Don't delete this file! It's used internally to help with page regeneration."}