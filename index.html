<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>Pomona by okb</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Pomona</h1>
        <h2>The goddess of fruit trees, garden, and orchards</h2>

        <section id="downloads">
          <a href="https://github.com/okb/Pomona/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/okb/Pomona/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/okb/Pomona" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1>
<a name="p%C5%8Dm%C5%8Dna-the-dto-free-way-to-rest-for-lazy-people" class="anchor" href="#p%C5%8Dm%C5%8Dna-the-dto-free-way-to-rest-for-lazy-people"><span class="octicon octicon-link"></span></a>Pōmōna. The DTO-free way to REST for lazy people!</h1>

<p>Pōmōna is all about exposing your domain model as a REST API. With less pain.</p>

<p>It was born out of my personal experience with being bored from manually implementing
a whole new layer of DTO (Data Transfer Object) and mapping, with the feeling that I
was repeating myself over and over.</p>

<p>So the goal is that Pōmōna will offer a way to do this mapping and (de)serialization
by convention, and remove the need for DTO's all together. This shall be achieved by:</p>

<ul>
<li>Supporting custom conventions, with a good set of default ways to do things.</li>
<li>Expose an API to override these conventions for special cases. (TODO)
Yeah sure it should be Fluent, for the cool kids! ;)</li>
<li>Making it possible to generate an easy-to-use .NET client dll on-the-fly.</li>
<li>Make it possible to specify what references to expand and not.</li>
</ul><p>Additionally I also want it to be able to:</p>

<ul>
<li>Semi-automatic management of REST API versioning by inspection of changes in JSON schema. (TODO)</li>
</ul><p>Oh, by the way, for all nitpickers out there. I use the REST definition freely. I believe
it will be possible to expose a somewhat RESTful API through Pōmōna someday, but oh course
it all depends on the domain model mapped.</p>

<h2>
<a name="state-of-the-project" class="anchor" href="#state-of-the-project"><span class="octicon octicon-link"></span></a>State of the project</h2>

<p>Although usable for simple scenarios, Pōmōna should be considered early work-in-progress stuff.
It will change. A lot. It's for the adventurous and the rebels! ;)</p>

<p>My personal goal is to release a version 1.0 before christmas. But no promises, yet.</p>

<h2>
<a name="on-the-shoulders-of-really-cool-people" class="anchor" href="#on-the-shoulders-of-really-cool-people"><span class="octicon octicon-link"></span></a>On the shoulders of really cool people:</h2>

<ul>
<li>
<a>JSON.NET</a> for serialization stuff. h</li>
<li>
<a href="http://nancyfx.org/">Nancy</a> for hosting the web service. 
I really love Nancy! I can't overstate how good I think it is! &lt;3 &lt;3 &lt;3
One day I hope Pōmōna will offer a Super-Duper-Happy path just like it.</li>
<li>
<a href="http://www.nunit.org/">NUnit</a> for testing.</li>
<li>
<a href="http://www.mono-project.com/Cecil">Cecil</a> for generation of Client dll.</li>
<li>
<a href="http://code.google.com/p/google-code-prettify/">google-code-prettify</a> for presenting JSON as HTML.</li>
</ul><p>A huge thank you to all the authors of these projects.</p>

<h2>
<a name="getting-started" class="anchor" href="#getting-started"><span class="octicon octicon-link"></span></a>Getting started</h2>

<p>So if you really want to check this stuff out, here's how you get started.</p>

<ol>
<li>Implement your own <code>IPomonaDataSource</code>
</li>
<li>Inherit from <code>TypeMappingFilterBase</code>, and at a minimum implement <code>GetSourceTypes()</code> and <code>GetIdFor()</code>.
They're abstract, so you can't miss them.
<code>GetSourceTypes()</code> must return the list of what Types to expose to web service.</li>
<li>Inherit <code>PomonaModule</code> (which is a Nancy module), and treat this as you normally would treat a Nancy module.
Which could mean zero configuration. Just because Nancy is <em>that</em> awesome!</li>
<li>Inherit PomonaConfigurationBase and fill in the abstracts.</li>
</ol><p>Look at the Critter example in the source code for details. If you fire up the <code>Pomona.Example.ServerApp.exe</code>, it expose the critters on port 2211.
When ServerApp is running go here with a web browser to see what Pōmōna is all about:</p>

<ul>
<li><code>http://localhost:2211/critters</code></li>
<li><code>http://localhost:2211/critters?$expand=critter.hat</code></li>
<li>
<code>http://localhost:2211/Critters.Client.dll</code> - Generates a client library on-the-fly</li>
<li>
<code>http://localhost:2211/Critters.Client.1.0.0.0.nupkg</code> - Generates a <a href="http://www.nuget.org/">NuGet Package</a> for the client library on-the-fly</li>
<li>
<code>http://localhost:2211/schemas</code> - Returns the JSON schema for the transformed data model</li>
<li>
You can also <code>POST</code> to <code>http://localhost:2211/critter</code> create a new critter entity, or <code>PUT</code> to <code>http//localhost:2211/critter/&lt;id&gt;</code> to update the values of a critter.</li>
</ul><h2>
<a name="roadmap-for-first-release" class="anchor" href="#roadmap-for-first-release"><span class="octicon octicon-link"></span></a>Roadmap for first release</h2>

<p>Features:</p>

<ul>
<li>Add tests for serialization and deserialization on client DONE</li>
<li>Create IPomonaDataSource, for retrieval of data. DONE</li>
<li>Create PomonaSession and PōmōnaSessionFactory that will bind everything together.</li>
<li>Write correct metadata for generated client dll (AssemblyInfo etc..)</li>
<li>Implement support for value types (which is always expanded, and don't have URI). 90% DONE.</li>
<li>Implement simple query mechanism (Linq? relinq? something simpler?) 90% DONE.

<ul>
<li>Syntax inspired by OData, with some differences.</li>
<li>Most OData operators are supported, but functions are missing.</li>
</ul>
</li>
<li>Create a test helper that will compare an existing JSON schema with new one,
then detect any breaking changes in API.</li>
<li>Implement proper PATCH functionality.</li>
<li>ETags and versioning</li>
</ul><h2>
<a name="future-tasks" class="anchor" href="#future-tasks"><span class="octicon octicon-link"></span></a>Future tasks</h2>

<ul>
<li>Implement JS client lib. Maybe two types, one based on KnockoutJs? That would be cool.</li>
<li>Implement html media type for friendly browseing.</li>
<li>Implement batch fetching on client side</li>
<li>Batch query support, for example by encapsulating an array of http operations in a JSON array</li>
</ul><h1>
<a name="brainstorm-area" class="anchor" href="#brainstorm-area"><span class="octicon octicon-link"></span></a>Brainstorm area</h1>

<h2>
<a name="implementation-of-automatic-api-compatibility-checking" class="anchor" href="#implementation-of-automatic-api-compatibility-checking"><span class="octicon octicon-link"></span></a>Implementation of automatic API compatibility checking</h2>

<p>For this to work we need to:</p>

<ul>
<li>Have a api schema folder specified.</li>
<li>Have a method writing out existing schemas with version numbering: {api-name}.{version}.json</li>
<li>Find a way to whitelist a breaking API change.</li>
<li>Implement class ApiChangeVerifier.</li>
<li>Encourage having an ignored test that outputs current schema.</li>
</ul><h2>
<a name="random-ideas" class="anchor" href="#random-ideas"><span class="octicon octicon-link"></span></a>Random ideas</h2>

<ul>
<li><p>Could make query mechanism pluggable, through some sort of <code>IHttpQueryTranslator</code>.
Then we could provide a simple default implementation.</p></li>
<li><p>An exotic side-project could be to implement an <code>IHttpQueryTranslator</code> that uses relinq
to serialize and convert LINQ expressions, which then can be executed on Nhibernate or other ORM.
This does however seem a bit dangerous with regards to security.</p></li>
</ul><h2>
<a name="automated-batching-of-queries-to-decrease-n1-performance-problems" class="anchor" href="#automated-batching-of-queries-to-decrease-n1-performance-problems"><span class="octicon octicon-link"></span></a>Automated batching of queries to decrease N+1 performance problems</h2>

<p>The classic N+1 problem will appear when looping through a list, where we at each step
access a reference to another object, which will then be loaded. Although Pōmōna supports
sending a list of expanded paths to deal with these problems, it would be sorta cool if
this could be detected runtime and fixed.</p>

<p>This is one way to do it (by example). We got two simple entity types:</p>

<p>Customer example:</p>

<div class="highlight highlight-json"><pre><span class="p">{</span>
    <span class="nt">"name"</span> <span class="p">:</span> <span class="s2">"The first name"</span><span class="p">,</span>
    <span class="nt">"order"</span> <span class="p">:</span> <span class="p">{</span>
        <span class="nt">"_ref"</span> <span class="p">:</span> <span class="s2">"http://blah/order/1"</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Order example:</p>

<div class="highlight highlight-json"><pre><span class="p">{</span>
    <span class="nt">"_uri"</span> <span class="p">:</span> <span class="s2">"http://blah/order/1"</span><span class="p">,</span>
    <span class="nt">"description"</span> <span class="p">:</span> <span class="s2">"This is a order"</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>

<p>This can be accomplished by keeping track of what properties have been accessed, and in what order.</p>

<p>Lets say we get a list of 30 customers by some criteria that is supposed to be presented
in a table along with the order description.. And we iterate through the customers in order.</p>

<p>Total query count: 1</p>

<p><code>customers[0].Order.Description</code> is accessed first, which, as is normal, makes the first order loaded.
We take a note that Order of description has been loaded for first Customer, and double the prefetch
count for the path Customer.Order, from 1 (no prefetching) to 2.</p>

<p>Total query count: 2</p>

<p><code>customers[1].Order.Description</code> is accessed next time, which loads Order for both customer #1 and customer #2.
Then prefetch count is doubled again from 2 to 4.</p>

<p><code>customers[2].Order</code> is already prefetched, so nothing needs to be loaded for that.</p>

<p>Total query count: 3</p>

<p>The <code>customers[3].Order</code> is accessed, which loads Order for customer #3,#4,#5,#6. The prefetch count is
doubled again.</p>

<p>Total query count: 4</p>

<p>And so on:</p>

<p>Query 5: Order #7, #8, #9, #10, #11, #12, #13, #14 loaded
Query 6: Order #15, #16, #17, #18, #19, #20, #21, #22, #23, #24 loaded</p>

<p>This gives a total of 6 http requests instead of 26, which means instead of N+1 we have Log2(N)+1 operations.</p>
      </section>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-7336224-10");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>